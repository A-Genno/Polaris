# エージェント開発ガイドライン

## 1. 本ドキュメントの目的と対象

本ドキュメントは、Polaris プロジェクトにおける **人間の開発メンバー** および **LLM エージェント** の双方が遵守すべき共通ルールと、エージェント特有の運用ルールを定義する。

- 明示がない限り、本ドキュメントの規則は「人間／エージェント共通」とする。
- 「11. エージェント運用ガイドライン」は、特に LLM エージェント運用に特化した補足ルールである。
- プロジェクト固有の仕様・要件ドキュメントに矛盾がある場合は、そちらを優先し、本ドキュメントは原則としてガイドライン（原則・推奨）とする。

---

## 2. コミュニケーション規則
- **言語**: チャットでの応答、PR、コミットコメント、コード内コメントは全て日本語で記述
- **敬語**: ユーザーとのやり取りは丁寧語を使用
- **確認**: 実装前に必ず要件と設計について確認を取る
  - 仕様の解釈が結果に大きく影響する場合は、ユーザーまたはリーダーエージェントに確認する。
  - 軽微な UI 調整や一貫性維持など、影響範囲が限定的な場合は過去実装との一貫性を優先して自律判断してよい。
- **進捗報告**: 作業の進行状況を適宜報告する
  - 長時間タスクでは、チェックポイントごとに中間報告を行う。


---

## 3. ドキュメント管理

### 3.1 作業記録
- 作業完了後に作業内容を記載した `.md` ファイルを `/documents` ディレクトリ以下に作成する
- ファイルには必ず「意図（なぜその作業を行ったか）」を明記する
- ファイル名は `YYYYMMDD_作業内容.md` 形式を推奨

### 3.2 ドキュメント構成
- **場所**: `documents/` ディレクトリ以下に集約
- **種類**: 要件定義、設計書、API 仕様、運用手順、作業記録
- **更新**: 実装と同期してドキュメントも更新
- **参照**: 実装前に関連ドキュメントの存在を必ず確認

### 3.3 ドキュメント作成ルール
- **言語**: 全て日本語で記述
- **形式**: Markdown 形式を基本とする
- **構成**: 目的、概要、詳細、例の順で構成
- **更新履歴**: 重要な変更は履歴として記録

### 3.4 必要なドキュメント
- **README.md**: プロジェクト概要と環境構築手順
- **ARCHITECTURE.md**: システム設計とアーキテクチャ
- **UIUX.md**: UI/UX 設計と方針
- **api.md**: API 仕様とエンドポイント一覧
- **deployment.md**: デプロイ手順と環境設定
- **troubleshooting.md**: よくある問題と解決方法

---

## 4. 設計・アーキテクチャ原則
- **クリーンアーキテクチャ**: 高い保守性とテスト性を前提とした依存関係の制御
- **ドメイン駆動設計**: ビジネスロジックの中心化と明確な境界の設定
- **SOLID原則**: 単一責任、開放閉鎖、リスコフ置換、インターフェース分離、依存性逆転
- **参照ドキュメント**: 詳細なアーキテクチャは `ARCHITECTURE.md` を参照
- **アーキテクチャ変更時の記録**: アーキテクチャに関わる設計判断・変更は必ず `ARCHITECTURE.md` に記載・更新すること
- **設計パターン**: Entity, Repository, UseCase, Service パターンの適用を検討

---

## 5. 実装タスクフロー

### 5.1 事前調査フェーズ
- **要件収集**: 実装に必要な情報をユーザーから網羅的に収集
- **仕様明確化**: 曖昧な点や不明な仕様は必ずユーザーに確認
- **既存コード調査**: プロジェクト構成と既存実装を十分に理解

### 5.2 設計フェーズ
- **設計提示**: 実装アプローチと技術選択を明確に提示
- **計画承認**: 設計と実装計画についてユーザーの承認を必ず取得
- **影響範囲確認**: 変更による他コンポーネントへの影響を検討

### 5.3 実装フェーズ
- **段階的実装**: 小さな単位で実装し、動作確認を繰り返す
- **命名規則**: クラス、関数、変数名は自己説明的で意図が明確なものを使用
- **コメント**: 複雑なロジックには適切な日本語コメントを付与
- **セットテスト**: 新規作成したコンポーネントには必ずテストを実装

---

## 6. UI/UX設計戦略

### 6.1 基本原則
- **ユーザー中心設計**: ユーザーの目標達成を最優先に考えた設計
- **一貫性**: アプリケーション全体で統一されたデザインパターンとインタラクションを維持
- **アクセシビリティ**: 多様なユーザーが利用できるよう WCAG ガイドラインに準拠
- **レスポンシブデザイン**: 様々なデバイス・画面サイズに対応

### 6.2 デザインシステム
- **コンポーネント設計**: 再利用可能な UI コンポーネントをライブラリ化
- **カラーパレット**: ブランドカラーとセマンティックカラーを定義
- **タイポグラフィ**: フォントファミリー、サイズ、行間を統一
- **スペーシング**: 余白・間隔のルールを一貫して適用

### 6.3 インタラクション設計
- **フィードバック**: ユーザー操作に対して即座に視覚的フィードバックを提供
- **エラーハンドリング**: エラー発生時は原因と解決方法を明確に提示
- **ローディング状態**: 処理中であることをユーザーに適切に伝達
- **マイクロインタラクション**: 細かな動きでユーザー体験を向上

### 6.4 参照ドキュメント
- **詳細仕様**: UI/UX の詳細な設計指針・コンポーネント仕様は `UIUX.md` を参照
- **変更時の記録**: UI/UX に関わる設計判断・変更は必ず `UIUX.md` に記載・更新すること

---

## 7. テスト実装戦略

### 7.1 テスト設計原則
- **網羅性**: 正常ケース、エラーケース、境界値、エッジケースを全て実装
- **独立性**: 各テストは他のテストに依存せず独立して実行可能
- **可読性**: テストコードは仕様書として機能するよう明確に記述
- **保守性**: テスト対象の変更に対して柔軟に対応できる構造

### 7.2 モック化戦略
- **DBアクセス**: リポジトリパターンでモック化またはフィクスチャを使用
- **外部API**: HTTPクライアントをモック化し、レスポンスパターンを網羅
- **時間依存処理**: 現在時刻やタイマー処理は固定値でモック化
- **ファイルI/O**: ファイルシステムアクセスは仮想ファイルシステムを使用

### 7.3 テスト実装手順
1. **機能分析**: テスト対象コンポーネントの全機能を詳細に調査
2. **テストケース設計**: 機能ごとに正常 / 異常 / 境界値ケースを洗い出し
3. **テスト実装**: テスト対象コードは変更せずテストのみ実装
4. **実行確認**: 全てのテストが期待通りに通過することを確認
5. **カバレッジ確認**: コードカバレッジ 100% を目指す

### 7.4 テストコード品質基準
- **AAA パターン**: Arrange（準備）、Act（実行）、Assert（検証）を明確に分離
- **テスト名**: テスト内容が一目で分かる日本語での命名
- **アサーション**: 期待値と実際の値を明確に比較
- **エラーメッセージ**: 失敗時に問題箇所が特定できるメッセージ

---

## 8. コード品質基準

### 8.1 設計原則
- **単一責任の原則**: 一つのクラス / 関数は一つの責任のみを持つ
- **開放閉鎖の原則**: 拡張に対して開いており、修正に対して閉じている
- **依存性逆転の原則**: 抽象に依存し、具象に依存しない
- **インターフェース分離の原則**: 使用しないメソッドへの依存を強制しない

### 8.2 コーディング規約
- **命名規則**:
  - クラス: PascalCase（例: `UserRepository`）
  - 関数 / 変数: camelCase（例: `getUserById`）
  - 定数: UPPER_SNAKE_CASE（例: `MAX_RETRY_COUNT`）
- **関数設計**: 一つの関数は 20 行以内、引数は 3 個以内を目標
- **コメント**: WHY を説明し、WHAT は説明しない
- **マジックナンバー**: 定数として定義し、意味のある名前を付ける

### 8.3 リファクタリング指針
- **既存コード調査**: 変更対象の全体像を把握してから着手
- **影響範囲分析**: 変更による他コンポーネントへの影響を事前に確認
- **段階的改善**: 大きな変更は小さな単位に分割して実施
- **後方互換性**: 既存 API の互換性を可能な限り維持

---

## 9. セキュリティガイドライン

### 9.1 機密情報管理
- **環境変数**: `.env.local` を使用し、**絶対にコミットしない**
- **API キー**: 外部サービスの API キーは環境変数で管理
- **データベース認証情報**: 本番・開発環境で異なる認証情報を使用
- **ログ出力**: 個人情報（PII）をログに出力しない

### 9.2 セキュリティチェックリスト
- **SQLインジェクション**: ORM やプリペアドステートメントを使用
- **XSS対策**: 出力時の適切なエスケープ処理
- **CSRF対策**: CSRF トークンの実装
- **認証・認可**: 適切な権限チェックの実装
- **HTTPS**: 本番環境では必ず HTTPS 通信を使用

### 9.3 禁止事項
- 外部 URL への無許可での `curl` 実行
- 機密情報のハードコーディング
- 本番データベースへの直接アクセス
- セキュリティホールを作る可能性のあるライブラリ使用

---

## 10. 開発ツールとコマンド

### 10.1 許可コマンド
- **パッケージ管理**: `pnpm`, `npm`, `pip`
- **バージョン管理**: `git` 全般
- **コンテナ**: `docker`, `docker-compose`
- **クラウド**: `gcloud`（dry-run 優先）
- **データベース**: `psql`, `mysql`
- **テスト**: `jest`, `pytest`

### 10.2 禁止・制限コマンド
- **危険コマンド**: `rm -rf /`, `sudo rm`
- **外部通信**: `curl` での外部送信（明示許可時のみ可）
- **システム変更**: システム設定を変更するコマンド
- **本番環境操作**: 本番データベースの直接操作

---

## 11. Git ワークフローと PR 管理

### 11.1 ブランチ戦略
- **命名規則**: `feat/*`, `fix/*`, `docs/*`, `refactor/*`, `test/*`, `chore/*`
- **ベースブランチ**: 基本的に `main` ブランチから分岐
- **ブランチ寿命**: 機能実装完了後は速やかにマージ・削除
- **並行開発**: 機能ごとに独立したブランチで開発

### 11.2 コミット規約
- **スタイル**: Conventional Commits 形式を厳守
- **例**: `feat: ユーザーログイン機能を追加`, `fix: パスワード検証バグを修正`
- **粒度**: 論理的に関連する変更を一つのコミットにまとめる
- **頻度**: 機能の区切りで定期的にコミット

### 11.3 プルリクエスト作成基準
- **言語**: タイトル・説明文は日本語で記述
- **タイトル**: 実装した機能・修正内容を簡潔に要約
- **概要**: その PR で行った作業を 1 行で明確に記述
- **修正内容**: 変更内容を具体的に箇条書きで詳述
- **テスト**: 実装したテストケースと動作確認結果を記載
- **スクリーンショット**: UI 変更がある場合は変更前後の画像を添付

### 11.4 レビュー観点
- **機能性**: 要求通りに動作するか
- **設計**: アーキテクチャ原則に準拠しているか
- **可読性**: コードが理解しやすいか
- **テスト**: 適切なテストが実装されているか
- **パフォーマンス**: 性能面で問題がないか

---

## 12. エージェント運用ガイドライン

### 12.1 運用目的
リーダーエージェントを中心とした小規模チームを編成し、調査・設計・実装などのタスクを自律的かつ継続的に遂行する枠組みを整える。

### 12.2 チーム体制と役割
- **リーダーエージェント**: タスク全体を俯瞰し、ゴール・優先度・締切を明確化して実装エージェントへ指示を出し、進行状況を監視する。
- **実装エージェント**: リーダーエージェントが実装タスクを進行するために起動する。リーダーエージェントから割り当てられた単一タスクのみを担当し、完了または障害発生時に速やかにリーダーへ報告する。
- **コードレビューエージェント**: 実装エージェントがコードを変更または新規作成したときに起動し、コードレビューを実施する。問題箇所を発見した場合は実装エージェントに報告し、修正を依頼する。

### 12.3 ワークフロー
1. リーダーエージェントがタスクを調査・実装・検証などに分類し、優先順位と期待成果を整理する。
2. タスクを複数の自律実行可能な単位に分割し、必要な専門性ごとに子エージェント（調査・実装・検証など）を `gemini` コマンドで起動する。起動時には担当範囲、完了条件、想定所要時間を必ず記録する。
3. 各実装エージェントに対し、担当タスク・目的・完了条件・想定所要時間・連絡方法を明示して割り当てる。実装エージェントは自律判断で更に子エージェントが必要と判断した場合、事前にリーダーへ意図を共有した上で起動する。
4. 実装エージェントは担当タスクを遂行し、分岐した作業やリスクが発生した際は即時にリーダーへ共有する。中間報告が必要な場合はチェックポイント単位で子エージェントの状況も合わせて報告する。
5. タスク完了後、実装エージェントは成果物・観測事項・リスク・起動した子エージェントの結果をリーダーエージェントへ報告し承認を得る。
6. リーダーは報告を評価し、次アクション（再調査、追加実装、別の実装エージェントへの引継ぎなど）を決定する。
7. 必要に応じてタスク一覧を更新し、稼働中の子エージェントの停止・再割り当てを含めた新規指示を出す。
8. 実装エージェントがコードを変更または新規作成したときにコードレビューエージェントを起動し、審査結果をリーダーに共有する。

### 12.4 自律性と確認方針（エージェント向け）

エージェントは以下の方針に従って、自律判断とユーザー / リーダーへの確認を使い分ける。

- **必ず確認が必要なケース**
  - 仕様の解釈によって UI / API のインターフェースが大きく変わる場合
  - 既存ユーザーに影響する互換性（後方互換性）の有無が判断できない場合
  - セキュリティや課金、データ削除など、リスクの高い処理を変更する場合
- **自律判断が許容されるケース**
  - 文言微調整、ログメッセージの改善など軽微な変更
  - 既存コードとの一貫性を保つための命名やスタイルの調整
  - 実装詳細が未指定だが、一般的な設計原則（本ガイドライン）から自然に導ける場合

疑義が残る場合は、「暫定案を提示した上で確認を求める」形でコミュニケーションすることを推奨する。

### 12.5 コミュニケーションとレポート
- リーダーエージェントへの報告は「目的・現状・問題・次アクション」を明記した短いメモ形式で行う。
- 重大なリスクやブロッカーが発生した場合は、経過報告を待たずに即時共有する。
- 子エージェントの起動・停止時には、起動理由・担当範囲・完了状況をワンライナーで共有し、タスクログに紐付ける。

#### 12.5.1 タスク報告テンプレート例

```md
[目的]
- XXX 機能の YYY を実装するため

[現状]
- ZZZ まで完了、AAA が未着手

[問題]
- 外部 API のレスポンス仕様が不明
- テストデータが不足している

[次アクション]
- ユーザーに API スキーマを確認する
- 仮のモックレスポンスでユニットテストを先に作成する
```

#### 12.5.2 子エージェント起動ログテンプレート例

```md
[子エージェント起動]
- 種別: 実装エージェント / 調査エージェント / 検証エージェント
- タスクID: TASK-123
- 担当範囲: /usecases/GetUserProfile のユニットテスト実装
- 完了条件: 正常系とエラー系 (404, 500) のテストがグリーンになること
- 想定所要時間: 30 分
```

### 12.6 コマンド利用ルール
- **使用許可コマンド**: `gemini`
- リーダーエージェントが実装タスク開始時に実装エージェントの起動・停止を実行し、指示内容を `gemini` 実行ログに残す。
- 実装エージェントは自律判断で必要な子エージェント（調査補助、検証補助など）を `gemini` で起動できるが、起動前にリーダーへ意図を共有し、コマンド出力を報告ログへ添付する。
- 実装エージェントはコードの変更もしくは新設時にコードレビューエージェントを起動してコードレビューを依頼し、レビュー結果を `gemini` ログとセットで保存する。
- コマンド実行ログはタスク報告に添付し、再現性を確保する。

### 12.7 安全運用上の注意
- 同一リポジトリやリソースに対する並列更新はリーダーが調整し、競合を事前に回避する。
- 外部システムへのアクセスや高リスク操作は必ずリーダーの事前承認を得る。
- 長時間タスクは途中経過のチェックポイントを設定し、メンバーと稼働中の子エージェントの状況を可視化する。
- 子エージェントの停止漏れを防ぐため、タスク終了時に稼働状況を点検し、不要なエージェントを速やかに停止する。

### 12.8 運用の KPI と振り返り
エージェントチーム運用の健全性を評価するため、以下のような指標を定期的に確認することを推奨する。

- タスクあたりの再実行率（やり直し・手戻りの件数）
- 子エージェントの平均起動時間・平均完了時間
- PR あたりの平均レビュー指摘件数
- 重大インシデント（セキュリティ・データ破壊など）の発生件数

これらの指標は、定期的な振り返りの際に確認し、ガイドラインやワークフローの改善に反映する。
